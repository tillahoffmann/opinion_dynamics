__author__ = 'tillhoffmann'

import numpy as np
import networkx as nx


def simulate(graph, initial_balls, num_steps):
    """
    Generates a step sequence `S[t, :]` of prior updates. Each row of `S` represents one time step. At time `t`, node
    `S[t,0]` transfers a ball of color `S[t,2]` to node `S[t,1]`.
    :param graph: The graph to simulate dynamics on.
    :param initial_balls: A 2D-array representing the initial ball configuration. The element `initial_balls[i,c]`
    represents the number of balls of color `c` that node `i` holds.
    :param num_steps: The number of steps to simulate the dynamics for.
    :return: A step sequence.
    """
    edges = graph.edges()
    num_edges = len(edges)
    balls = np.array(initial_balls)

    steps = []

    for step in range(num_steps):
        # Select an edge
        edge = edges[np.random.randint(num_edges)]
        # Get a transmitter and receiver
        t, r = np.random.permutation(edge)
        # Compute the probability to draw a ball from the transmitter
        probability = float(balls[t, 0]) / np.sum(balls[t])
        # Draw a ball
        ball = int(probability > np.random.uniform())
        # Update the balls
        balls[r, ball] += 1
        # Add to the steps
        steps.append((t, r, ball))

    return np.array(steps)


def evaluate_statistic(initial_balls, steps, statistic):
    """
    Evaluates the specified statistic as a function of the time.
    :param balls: A 2D-array representing the initial ball configuration. The element `initial_balls[i,c]` represents
    the number of balls of color `c` that node `i` holds.
    :param steps: The step sequence generated by `simulate`.
    :param statistic: A function that takes a ball configuration as input and computes a statistic.
    :return: A `np.array` of statistics evaluated as a function of time.
    """
    balls = np.array(initial_balls)
    statistics = []

    for _, r, ball in steps:
        balls[r, ball] += 1
        statistics.append(statistic(balls))

    return np.asarray(statistics)


def statistic_mean_belief_urn_weighted(balls):
    """
    Computes the mean urn-weighted belief.
    :param balls: A 2D-array representing a ball configuration. The element `initial_balls[i,c]` represents
    the number of balls of color `c` that node `i` holds.
    :return: The mean urn-weighted belief.
    """
    # Compute the mean belief of each urn
    belief = balls[:, 0] / np.sum(balls, axis=1)
    return np.mean(belief)


def statistic_mean_belief_ball_weighted(balls):
    """
    Computes the fraction of balls of color `0`.
    :param balls: A 2D-array representing a ball configuration. The element `initial_balls[i,c]` represents
    the number of balls of color `c` that node `i` holds.
    :return: The fraction of balls of color `0`.
    """
    # Compute the fraction of balls of a given colour
    return np.sum(balls[:, 0]) / np.sum(balls)


def _main():
    # Import plotting library
    import matplotlib.pyplot as plt
    # Fix a seed for reproducibility
    np.random.seed(42)

    # Define a number of nodes and simulation steps
    num_nodes = 100
    num_steps = 10000

    # Set up the initial ball configuration
    balls = np.ones((num_nodes, 2))
    # Set up a network
    graph = nx.erdos_renyi_graph(num_nodes, 5 / float(num_nodes))
    # Generate a number of steps
    steps = simulate(graph, balls, num_steps)

    # Evaluate the mean belief
    mean_belief = evaluate_statistic(balls, steps, statistic_mean_belief_urn_weighted)
    # Visualise the mean belief
    plt.plot(mean_belief)
    plt.xlabel('Time step')
    plt.ylabel('Urn-weighted mean belief')
    plt.tight_layout()
    plt.show()

if __name__=='__main__':
    _main()