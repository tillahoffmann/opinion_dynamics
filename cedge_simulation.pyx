cimport numpy as np
import numpy as np
from libc.stdlib cimport rand, RAND_MAX, srand
cimport cython
cdef extern from "time.h":
    unsigned long int time(unsigned long int)
ctypedef float (*f_type)(np.ndarray[np.float_t, ndim=2])

def seed_rng(seed=None):
    """
    Seeds the C random number generator.
    :param seed: The seed to supply the random number generator with. The seed is time-based if `None`.
    """
    # Get a time-based seed is none is supplied
    if seed is None:
        seed = time(0)
    # Set the seed
    srand(seed)

@cython.boundscheck(False)
@cython.cdivision(True)
cdef float cstatistic_mean_belief_urn_weighted(np.ndarray[np.float_t, ndim=2] balls):
    """
    See `statistic_mean_belief_urn_weighted`.
    """
    cdef float mean_belief = 0
    cdef int node, num_nodes = balls.shape[0]

    for node in range(num_nodes):
        mean_belief += balls[node, 0] / float(balls[node, 0] + balls[node, 1])

    return mean_belief / num_nodes


def statistic_mean_belief_urn_weighted(balls):
    """
    Computes the mean urn-weighted belief.
    :param balls: A 2D-array representing a ball configuration. The element `balls[i,c]` represents
    the number of balls of color `c` that node `i` holds.
    :return: The mean urn-weighted belief.
    """
    return cstatistic_mean_belief_urn_weighted(balls)

@cython.boundscheck(False)
@cython.cdivision(True)
cdef float cstatistic_mean_belief_ball_weighted(np.ndarray[np.float_t, ndim=2] balls):
    """
    See `statistic_mean_belief_ball_weighted`.
    """
    # Compute the fraction of balls of a given colour
    cdef float ball0 = 0, ball1 = 0
    cdef int node, num_nodes = balls.shape[0]

    for node in range(num_nodes):
        ball0 += balls[node, 0]
        ball1 += balls[node, 1]

    return ball0 / (ball0 + ball1)


def statistic_mean_belief_ball_weighted(balls):
    """
    Computes the fraction of balls of color `0`.
    :param balls: A 2D-array representing a ball configuration. The element `balls[i,c]` represents
    the number of balls of color `c` that node `i` holds.
    :return: The fraction of balls of color `0`.
    """
    # Compute the fraction of balls of a given colour
    return cstatistic_mean_belief_ball_weighted(balls)


@cython.boundscheck(False)
def evaluate_statistic(np.ndarray[np.float_t, ndim=2] initial_balls, np.ndarray[np.float_t, ndim=2] steps, statistic):
    """
    Evaluates the specified statistic as a function of the time.
    :param balls: A 2D-array representing the initial ball configuration. The element `initial_balls[i,c]` represents
    the number of balls of color `c` that node `i` holds.
    :param steps: The step sequence generated by `simulate`.
    :param statistic: A function that takes a ball configuration as input and computes a statistic.
    :return: A `np.array` of statistics evaluated as a function of time.
    """
    cdef np.ndarray[np.float_t, ndim=2] balls = np.array(initial_balls)
    cdef list statistics = []
    cdef int step, num_steps, ball, receiver
    cdef float number
    cdef f_type cstatistic
    cdef bint use_cstatistic = True

    # Check if there is a C implementation
    if statistic == statistic_mean_belief_ball_weighted:
        cstatistic = cstatistic_mean_belief_ball_weighted
    elif statistic == statistic_mean_belief_urn_weighted:
        cstatistic = cstatistic_mean_belief_urn_weighted
    else:
        # Just call the C function
        use_cstatistic = False

    # Iterate over the balls
    num_steps = steps.shape[0]
    for step in range(num_steps):
        # Update the ball configuration
        receiver = int(steps[step, 1])
        ball = int(steps[step, 2])
        number = steps[step, 3]
        balls[receiver, ball] += number
        # Compute the statistic
        if use_cstatistic != 0:
            statistics.append(cstatistic(balls))
        else:
            statistics.append(statistic(balls))

    return np.asarray(statistics)

@cython.cdivision(True)
@cython.boundscheck(False)
def simulate(graph, np.ndarray[np.float_t, ndim=2] initial_balls, int num_steps, output='steps',
             control=None, **kwargs):
    """
    Generates a step sequence `S[t, :]` of prior updates. Each row of `S` represents one time step. At time `t`, node
    `S[t,0]` transfers a ball of color `S[t,2]` to node `S[t,1]`.
    :param graph: The graph to simulate dynamics on.
    :param initial_balls: A 2D-array representing the initial ball configuration. The element `initial_balls[i,c]`
    represents the number of balls of color `c` that node `i` holds.
    :param num_steps: The number of steps to simulate the dynamics for.
    :param control: A function that implements a control strategy.
    :param kwargs: Extra keyword arguments passed to the control function.
    :return: A step sequence if `output=='steps'`. The last configuration if `output=='last'`.
    """
    cdef np.ndarray[np.int_t, ndim=2] edges = np.asarray(graph.edges(), dtype=np.int)
    cdef int num_edges = len(edges)
    cdef np.ndarray[np.float_t, ndim=2] balls = np.array(initial_balls, dtype=np.float)
    cdef list steps = []
    cdef int step, node, ball, neighbor, idx
    cdef float number, probability, u
    cdef np.ndarray[np.float_t, ndim=2] controls

    for step in range(num_steps):
        #Apply a control strategy if supplied
        if control is not None:
            #Get the controls
            controls = np.asarray(control(graph, balls, step, **kwargs), np.float)
            #Apply the controls
            for idx in range(controls.shape[0]):
                node = int(controls[idx, 0])
                ball = int(controls[idx, 1])
                number = controls[idx, 2]
                balls[node, ball] += number
                steps.append((None, node, ball, number))

        # Select an edge
        idx = rand() % num_edges
        node = edges[idx, 0]
        neighbor = edges[idx, 1]
        # Compute the probability to draw a ball from the transmitter
        probability = balls[node, 0] / float(balls[node, 0] + balls[node, 1])
        # Draw a ball
        u = rand() / float(RAND_MAX)
        ball = int(probability < u)
        # Update the balls
        balls[neighbor, ball] += 1
        # Add to the steps
        steps.append((node, neighbor, ball, 1))

    if output=='steps':
        return np.array(steps, dtype=np.float)
    elif output=='last':
        return balls
    else:
        raise ValueError("'{}' is an invalid output option.".format(output))
