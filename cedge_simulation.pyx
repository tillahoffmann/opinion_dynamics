cimport numpy as np
import numpy as np
from libc.stdlib cimport rand, RAND_MAX, srand
cimport cython
cdef extern from "time.h":
    unsigned long int time(unsigned long int)

def seed_rng(seed=None):
    if seed is None:
        seed = time(0)
    srand(seed)

@cython.boundscheck(False)
def evaluate_statistic(np.ndarray[np.float_t, ndim=2] initial_balls, np.ndarray[np.float_t, ndim=2] steps, statistic):
    """
    Evaluates the specified statistic as a function of the time.
    :param balls: A 2D-array representing the initial ball configuration. The element `initial_balls[i,c]` represents
    the number of balls of color `c` that node `i` holds.
    :param steps: The step sequence generated by `simulate`.
    :param statistic: A function that takes a ball configuration as input and computes a statistic.
    :return: A `np.array` of statistics evaluated as a function of time.
    """
    cdef np.ndarray[np.float_t, ndim=2] balls = np.array(initial_balls)
    cdef list statistics = []
    cdef int step, num_steps, ball, receiver
    cdef float number

    num_steps = steps.shape[0]
    for step in range(num_steps):
        receiver = int(steps[step, 1])
        ball = int(steps[step, 2])
        number = steps[step, 3]
        balls[receiver, ball] += number
        statistics.append(statistic(balls))

    return np.asarray(statistics)

@cython.cdivision(True)
@cython.boundscheck(False)
def simulate(graph, np.ndarray[np.float_t, ndim=2] initial_balls, int num_steps, output='steps',
             control=None, **kwargs):
    """
    Generates a step sequence `S[t, :]` of prior updates. Each row of `S` represents one time step. At time `t`, node
    `S[t,0]` transfers a ball of color `S[t,2]` to node `S[t,1]`.
    :param graph: The graph to simulate dynamics on.
    :param initial_balls: A 2D-array representing the initial ball configuration. The element `initial_balls[i,c]`
    represents the number of balls of color `c` that node `i` holds.
    :param num_steps: The number of steps to simulate the dynamics for.
    :param control: A function that implements a control strategy.
    :param kwargs: Extra keyword arguments passed to the control function.
    :return: A step sequence if `output=='steps'`. The last configuration if `output=='last'`.
    """
    cdef np.ndarray[np.int_t, ndim=2] edges = np.asarray(graph.edges(), dtype=np.int)
    cdef int num_edges = len(edges)
    cdef np.ndarray[np.float_t, ndim=2] balls = np.array(initial_balls, dtype=np.float)
    cdef list steps = []
    cdef int step, node, ball, neighbor, idx
    cdef float number, probability, u
    cdef np.ndarray[np.float_t, ndim=2] controls

    for step in range(num_steps):
        #Apply a control strategy if supplied
        if control is not None:
            #Get the controls
            controls = control(graph, balls, step, **kwargs)
            #Apply the controls
            for node, ball, number in controls:
                balls[node, ball] += number
                steps.append((None, node, ball, number))

        # Select an edge
        idx = rand() % num_edges
        node = edges[idx, 0]
        neighbor = edges[idx, 1]
        # Compute the probability to draw a ball from the transmitter
        probability = balls[node, 0] / float(balls[node, 0] + balls[node, 1])
        # Draw a ball
        u = rand() / float(RAND_MAX)
        ball = int(probability < u)
        # Update the balls
        balls[neighbor, ball] += 1
        # Add to the steps
        steps.append((node, neighbor, ball, 1))

    if output=='steps':
        return np.array(steps, dtype=np.float)
    elif output=='last':
        return balls
    else:
        raise ValueError("'{}' is an invalid output option.".format(output))
